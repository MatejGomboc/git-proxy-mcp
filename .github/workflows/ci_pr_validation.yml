name: CI - PR Validation

permissions:
    contents: read
    actions: write # Required for cache cleanup on main

on:
    push:
        branches: [main] # Populate cache after PR merges

    pull_request:
        branches: ["**"]

    workflow_dispatch:

env:
    CARGO_TERM_COLOR: always
    RUSTFLAGS: "-Dwarnings"

jobs:
    # Fast checks that don't need platform matrix or heavy caching
    quick-checks:
        name: Quick Checks (fmt, docs)
        runs-on: ubuntu-latest

        steps:
            - name: Checkout repository
              uses: actions/checkout@v6

            - name: Install Rust toolchain
              uses: dtolnay/rust-toolchain@stable
              with:
                  components: rustfmt

            - name: Check formatting
              run: cargo fmt --all --check

            - name: Check documentation
              run: cargo doc --no-deps --document-private-items
              env:
                  RUSTDOCFLAGS: "-Dwarnings"

    # Combined build job: clippy + build + test in one job per platform
    # This avoids recompilation across separate jobs
    build:
        name: Build (${{ matrix.os }})
        needs: quick-checks
        timeout-minutes: 20

        strategy:
            fail-fast: false
            matrix:
                os: [ubuntu-latest, macos-latest, windows-latest]

        runs-on: ${{ matrix.os }}

        steps:
            - name: Checkout repository
              uses: actions/checkout@v6

            - name: Install Rust toolchain
              uses: dtolnay/rust-toolchain@stable
              with:
                  components: clippy

            # Cache cargo registry, index, and build artifacts
            # PRs: restore only (read-only). Main: restore and save.
            - name: Cache Rust dependencies
              id: rust-cache
              uses: Swatinem/rust-cache@v2
              with:
                  # Only save cache on main branch pushes
                  save-if: ${{ github.ref == 'refs/heads/main' }}
                  # Shared cache key prefix
                  prefix-key: "v1-rust"
                  # Include Cargo.lock in cache key
                  cache-on-failure: true

            # Delete old caches only on cache miss (new cache will be created)
            # This prevents stale caches from accumulating
            # Matches any version prefix (v1, v2, etc.) to clean up after version bumps
            - name: Cleanup old caches (main, cache miss only)
              if: github.ref == 'refs/heads/main' && steps.rust-cache.outputs.cache-hit != 'true'
              run: |
                  echo "Cache miss detected - cleaning up old caches..."

                  # List caches matching any version prefix for this OS
                  # Pattern: v<number>-rust-<OS>
                  CACHE_KEYS=$(gh actions-cache list --branch main --limit 100 | \
                      grep -E "^v[0-9]+-rust-${{ runner.os }}" | cut -f1) || true

                  if [ -n "$CACHE_KEYS" ]; then
                      echo "Found old caches to delete:"
                      for KEY in $CACHE_KEYS; do
                          echo "  Deleting: $KEY"
                          gh actions-cache delete "$KEY" --branch main --confirm || true
                      done
                  else
                      echo "No old caches found"
                  fi
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  GH_REPO: ${{ github.repository }}

            - name: Run Clippy
              run: cargo clippy --all-targets --all-features -- -D warnings

            - name: Build (debug)
              run: cargo build --verbose

            - name: Build (release)
              run: cargo build --release --verbose

            - name: Run tests
              run: cargo test --verbose

    # Summary job for branch protection
    ci-success:
        name: CI Success
        needs: [quick-checks, build]
        runs-on: ubuntu-latest
        if: always()

        steps:
            - name: Check if all jobs succeeded
              run: |
                  if [[ "${{ needs.quick-checks.result }}" != "success" ]] || \
                     [[ "${{ needs.build.result }}" != "success" ]]; then
                      echo "One or more jobs failed"
                      exit 1
                  fi
                  echo "All jobs completed successfully"
